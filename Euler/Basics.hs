module Euler.Basics where

import Data.List
import Data.Bits

dividers :: Integer -> [Integer]
dividers n = [2..ceiling(sqrt(fromIntegral n))]

divisors :: Integer -> [Integer]
divisors n = smallDividers ++ [(div n divider) | divider <- smallDividers, (not (elem (div n divider) smallDividers)) ]
    where smallDividers = filter (\x -> (mod n x) == 0) (dividers n)

properDivisors :: Integer -> [Integer]
properDivisors n = 1 : divisors n

isPalindromeList :: [Integer] -> Bool
isPalindromeList list = list == reverse list

isPalindrome :: Integer -> Bool
isPalindrome n | n < 10 = True
isPalindrome n = (isPalindromeList . digits) n

digits :: Integer -> [Integer]
digits n | n < 10 = [n]
digits n = digits (div n 10) ++ [mod n 10]

fromDigits :: [Integer] -> Integer
fromDigits list = foldl append 0 list
    where append num digit = num * 10 + digit

smallestCommonFactor :: Integer
smallestCommonFactor = head $ filter divisible [2520*step, 2521*step..((product [11..20])*2520)]
    where step = product (filter isPrime [11..20])
          divisible x = null (filter (/= 0) (map ($ x) [(flip mod) x | x <- [1..20]]))

factorial :: Integer -> Integer
factorial n = product [1..n]

fibonacciSequence :: [Integer]
fibonacciSequence = 1 : 1 : zipWith (+) fibonacciSequence (tail fibonacciSequence)

isPrime :: Integer -> Bool
isPrime 1 = False
isPrime 2 = True
isPrime n = all ((/= 0).(mod n)) [2..ceiling(sqrt(fromIntegral n))]

primes :: [Integer]
primes = filter isPrime [2..]

count :: (Eq a) => [a] -> a -> Int
count l e = length $ filter (==e) l

binary :: Integer -> [Integer]
binary 0 = [0]
binary 1 = [1]
binary x = binary (div x 2) ++ [mod x 2]

binaryFixed :: Integer -> Integer -> [Integer]
binaryFixed l number = (take toAdd zeroes) ++ bin
  where bin = binary number
        toAdd = (fromIntegral l) - (length bin)
        zeroes = 0:zeroes

collatzSequence :: Integer -> [Integer]
collatzSequence n | n == 1 = [1]
                  | even n = n : collatzSequence (div n 2)
                  | otherwise = n : collatzSequence ((3 * n) + 1)


pentagonalSequence :: [Integer]
pentagonalSequence = [div (x*(3*x - 1)) 2 | x <- [1..]]

isPentagonal :: Integer -> Bool
isPentagonal x = x == (head (dropWhile (< x) pentagonalSequence))

triangleSequence :: [Integer]
triangleSequence = [div (n * (n + 1)) 2 | n <- [1..]]

isTriangle :: Integer -> Bool
isTriangle x = x == (head (dropWhile (< x) triangleSequence))

hexagonalSequence :: [Integer]
hexagonalSequence = [n * (2 * n - 1) | n <- [1..]]

isHexagonal :: Integer -> Bool
isHexagonal x = x == (head (dropWhile (< x) hexagonalSequence))

primeFactors :: Integer -> [Integer]
primeFactors 1 = []
primeFactors 2 = [2]
primeFactors n = nub ((nextFactor n) : primeFactors (div n (nextFactor n)))
    where nextFactors n = dropWhile ((/= 0).(mod n)) (takeWhile (<= n) primes)
          nextFactor n = if (null (nextFactors n)) then 1 else head (nextFactors n)

{-|
  The sequence of triangle numbers is generated by adding the natural numbers.
  So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28.
  The first ten terms would be:
  1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
-}
triangularSequence :: [Integer]
triangularSequence = 1:zipWith (+) triangularSequence [2..]

isLychrel :: Integer -> Bool
isLychrel x = isLychrel' x 50

{-|
  If we take 47, reverse and add, 47 + 74 = 121, which is palindromic.
  A number that never forms a palindrome through the reverse and add process is called a Lychrel number.
-}
isLychrel' :: Integer -> Integer -> Bool
isLychrel' _ 0 = True
isLychrel' x i = if isPalindrome (sumReverse x) then False else isLychrel' (sumReverse x) (i - 1)
  where sumReverse x = x + (fromDigits . reverse . digits) x

{-|
  Naive implementation of Euler Problem 502. Generate all castles, check validity, count
-}
castles :: Integer -> Integer -> Integer
castles w h = genericLength [c | c <- (allCastles w h), (even . sum . (map (countBlocks))) c]

{-|
  Generates all possible castles, even invalid ones. Each level is introduced
  with a number, which in binary form represents blocks
-}
allCastles :: Integer -> Integer -> [[Integer]]
allCastles _ 0 = []
allCastles 0 _ = []
allCastles w h = addLevel [[base]] (h-1)
  where base = (2 ^ w)-1
        addLevel castles levelsLeft
            | levelsLeft == 0 = castles
            | otherwise = addLevel ([c ++ [p] | c <- castles, p <- [0..(last c)], (p == p .&. (last c))]) (levelsLeft-1)

{-|
  Counts amount of blocks within a castle row
-}
countBlocks :: Integer -> Integer
countBlocks = genericLength . (filter ((== 1).head)) . group . binary

--getBlocks :: Integer -> [Integer]
--getBlocks = (map (toInteger.(-1).(^ 2).sum::Integer)) . (filter ((== 1).head)) . group . binary

--allCastles' :: Integer -> Integer -> [[Integer]]
--allCastles' _ 0 = []
--allCastles' 0 _ = []
--allCastles' w h = addLevel [[base]] (h-1)

--allCastles2 :: Integer -> Integer -> [Integer]
--allCastles2 _ 0 = []
--allCastles2 0 _ = []
--allCastles2 base h = getBlocks base